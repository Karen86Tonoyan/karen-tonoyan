"""Pluggable helpers for simulating hybrid post-quantum signatures.
The code base that inspired this exercise expects Falcon, SPHINCS+, andDilithium signatures to be available on constrained hardware.  Shipkh thisrepository would add significant maintenance burden, so the helpers exposed bythis module are *pluggable*:``PlaceholderProvider``    A small deterministic implementation that mimics the control flow of the    real cryptographic primitives.  It is dependency-free and therefore always    available.  The implementation is **not secure** and must only be used for    testing.``OQSProvider``    When the optional :mod:`oqs` package (Open Quantum Safe) is installed the    module automatically registers providers backed by the reference    implementations bundled with OQS.  This allows real signing and verifying    without changing the public API.The public helpers (:func:`generate_keypair`, :func:`sign_message`,:func:`verify_message`, :func:`sign_frame`, :func:`verify_frame`) always routethrough the currently registered provider for a scheme.  Downstream code canoverride or unregister providers at runtime which makes the module flexible forexperimentation, integration tests, or future hardware accelerators."""from __future__ import annotationsfrom dataclasses import dataclassimport base64import hashlibimport jsonimport secretsfrom typing import Dict, Iterable, Optional, Protocol, Tuple__all__ = [    "AlgorithmSpec",    "PQKeyPair",    "UnsupportedSchemeError",    "InvalidSignatureError",    "FrameFormatError",    "generate_keypair",    "sign_message",    "verify_message",    "sign_frame",    "verify_frame",    "available_schemes",    "register_provider",    "unregister_provider",]class UnsupportedSchemeError(ValueError):    """Raised when an unsupported signature scheme is requested."""class InvalidSignatureError(ValueError):    """Raised when signature verification fails."""class FrameFormatError(ValueError):    """Raised when a serialized frame cannot be decoded."""@dataclass(frozen=True)class AlgorithmSpec:    """Simple container describing algorithm-specific constants."""    name: str    secret_size: int    public_size: int    signature_size: int    personalization: bytes@dataclass(frozen=True)class PQKeyPair:    """Represents a placeholder key pair for a post-quantum scheme."""    scheme: str    public_key: bytes    secret_key: bytes    def encode(self) -> Tuple[str, str, str]:        """Return tuple with the scheme and base64-encoded key material."""        return (            self.scheme,            base64.b64encode(self.public_key).decode("ascii"),            base64.b64encode(self.secret_key).decode("ascii"),        )class SignatureProvider(Protocol):    """Interface implemented by all concrete signature providers."""    spec: AlgorithmSpec    def generate_keypair(self, seed: Optional[bytes]) -> PQKeyPair:        """Create a new :class:`PQKeyPair`.        Providers may ignore ``seed`` when deterministic key generation is not        supported.  Callers should therefore treat seeded output as a besteffort optimisation useful primarily for testing.        """    def sign(self, message: bytes, keypair: PQKeyPair) -> bytes:        """Return a signature for ``message`` using ``keypair``."""    def verify(self, message: bytes, signature: bytes, public_key: bytes) -> bool:        """Return ``True`` when ``signature`` is valid for ``message``."""_PROVIDERS: Dict[str, SignatureProvider] = {}def _shake(data: Iterable[bytes], length: int) -> bytes:    digest = hashlib.shake_256()    for chunk in data:        digest.update(chunk)    return digest.digest(length)def _get_provider(scheme: str) -> SignatureProvider:    try:        return _PROVIDERS[scheme.lower()]    except KeyError as exc:  # pragma: no cover - defensive guard        raise UnsupportedSchemeError(f"Unsupported scheme: {scheme}") from excdef available_schemes() -> Tuple[str, ...]:    """Return the registered scheme identifiers."""    return tuple(_PROVIDERS.keys())def register_provider(scheme: str, provider: SignatureProvider, *, override: bool = False) -> None:    """Register ``provider`` for ``scheme``.    Parameters    ----------    scheme:        Name of the algorithm (case-insensitive).    provider:        Object implementing :class:`SignatureProvider`.    override:        When ``True`` an existing provider will be replaced.  The flag defaults        to ``False`` to avoid surprising call sites.    """    key = scheme.lower()    if key in _PROVIDERS and not override:        raise ValueError(f"Provider already registered for {scheme}")    _PROVIDERS[key] = providerdef unregister_provider(scheme: str) -> None:    """Remove the provider registered for ``scheme``."""    try:        del _PROVIDERS[scheme.lower()]    except KeyError as exc:  # pragma: no cover - defensive guard        raise UnsupportedSchemeError(f"Unsupported scheme: {scheme}") from excclass PlaceholderProvider:    """Deterministic provider used when real PQ primitives are unavailable."""    def __init__(self, spec: AlgorithmSpec):        self.spec = spec    def _derive_public_key(self, secret_key: bytes) -> bytes:        return _shake((secret_key, self.spec.personalization, b"pk"), self.spec.public_size)    def generate_keypair(self, seed: Optional[bytes]) -> PQKeyPair:        if seed is None:            seed = secrets.token_bytes(self.spec.secret_size)        secret_key = _shake((seed, self.spec.personalization, b"sk"), self.spec.secret_size)        public_key = self._derive_public_key(secret_key)        return PQKeyPair(scheme=self.spec.name, public_key=public_key, secret_key=secret_key)    def sign(self, message: bytes, keypair: PQKeyPair) -> bytes:        if keypair.scheme.lower() != self.spec.name:            raise InvalidSignatureError(                f"Key pair scheme mismatch: expected {self.spec.name}, received {keypair.scheme}"            )        derived_public = self._derive_public_key(keypair.secret_key)        if derived_public != keypair.public_key:            raise InvalidSignatureError("Key pair mismatch; secret/public key do not align.")        return _shake(            (self.spec.personalization, keypair.public_key, message, b"sig"),            self.spec.signature_size,        )    def verify(self, message: bytes, signature: bytes, public_key: bytes) -> bool:        expected = _shake(            (self.spec.personalization, public_key, message, b"sig"),            self.spec.signature_size,        )        return secrets.compare_digest(signature, expected)def _register_default_placeholders() -> None:    register_provider(        "falcon",        PlaceholderProvider(            AlgorithmSpec(                name="falcon",                secret_size=48,                public_size=48,                signature_size=56,                personalization=b"falcon-placeholder",            )        ),    )    register_provider(        "sphincs",        PlaceholderProvider(            AlgorithmSpec(                name="sphincs",                secret_size=64,                public_size=64,                signature_size=64,                personalization=b"sphincs-placeholder",            )        ),    )    register_provider(        "dilithium",        PlaceholderProvider(            AlgorithmSpec(                name="dilithium",                secret_size=64,                public_size=48,                signature_size=48,                personalization=b"dilithium-placeholder",            )        ),    )def _register_oqs_providers() -> None:  # pragma: no cover - optional dependency    try:        import oqs    except ImportError:  # pragma: no cover - executed when oqs missing        return    class OQSProvider:        def __init__(self, scheme: str, algorithm: str):            self.scheme = scheme            self.algorithm = algorithm            with oqs.Signature(algorithm) as signature:                details = signature.details                self.spec = AlgorithmSpec(                    name=scheme,                    secret_size=details.length_secret_key,                    public_size=details.length_public_key,                    signature_size=details.length_signature,                    personalization=algorithm.encode("ascii", "ignore"),                )        def generate_keypair(self, seed: Optional[bytes]) -> PQKeyPair:            if seed is not None:                raise ValueError("Deterministic key generation is not supported by the OQS backend")            with oqs.Signature(self.algorithm) as signature:                public_key, secret_key = signature.generate_keypair()            return PQKeyPair(scheme=self.scheme, public_key=public_key, secret_key=secret_key)        def sign(self, message: bytes, keypair: PQKeyPair) -> bytes:            if keypair.scheme.lower() != self.scheme:                raise InvalidSignatureError(                    f"Key pair scheme mismatch: expected {self.scheme}, received {keypair.scheme}"                )            with oqs.Signature(self.algorithm) as signature:                return signature.sign(message, keypair.secret_key)        def verify(self, message: bytes, signature_value: bytes, public_key: bytes) -> bool:            with oqs.Signature(self.algorithm) as signature:                return signature.verify(message, signature_value, public_key)    oqs_algorithms = {        "falcon": "Falcon-1024",        "sphincs": "SPHINCS+-SHA2-128s-simple",        "dilithium": "Dilithium3",    }    for scheme, algorithm in oqs_algorithms.items():        try:            register_provider(scheme, OQSProvider(scheme, algorithm), override=True)        except Exception:            # Falling back to the placeholder provider keeps the module usable            # even when an individual OQS algorithm fails to initialise.            continue_register_default_placeholders()_register_oqs_providers()def generate_keypair(scheme: str, seed: Optional[bytes] = None) -> PQKeyPair:    """Generate a key pair for ``scheme`` using the active provider.    The placeholder providers support deterministic output when ``seed`` is    given which keeps unit tests reproducible.  Real providers (for example the    optional OQS backend) may raise :class:`InvalidSignatureError` when seeding    is not supported.    """    provider = _get_provider(scheme)    try:        return provider.generate_keypair(seed)    except ValueError as exc:        raise InvalidSignatureError(str(exc)) from excdef sign_message(message: bytes, keypair: PQKeyPair) -> bytes:    """Return a signature for ``message`` using ``keypair``.    The concrete behaviour depends on the active provider.  Placeholder    providers emit deterministic digests while real providers delegate to the    underlying cryptographic library.    """    provider = _get_provider(keypair.scheme)    return provider.sign(message, keypair)def verify_message(message: bytes, signature: bytes, scheme: str, public_key: bytes) -> bool:    """Validate ``signature`` for ``message`` using ``scheme`` and ``public_key``."""    provider = _get_provider(scheme)    return provider.verify(message, signature, public_key)def sign_frame(payload: bytes, keypair: PQKeyPair) -> bytes:    """Serialize ``payload`` alongside a signature and scheme marker.    The frame is a JSON blob containing base64 encoded payload and signature.    The structure keeps the implementation self-contained and is easy to    integrate with shell tooling, mirroring the user's request for concise    plumbing.    """    signature = sign_message(payload, keypair)    frame = {        "scheme": keypair.scheme,        "payload": base64.b64encode(payload).decode("ascii"),        "signature": base64.b64encode(signature).decode("ascii"),    }    return json.dumps(frame, separators=(",", ":")).encode("utf-8")def verify_frame(frame: bytes, public_key: bytes) -> Tuple[bytes, str]:    """Validate a serialized frame and return the payload and scheme.    Raises :class:`FrameFormatError` on JSON parsing issues and    :class:`InvalidSignatureError` if the signature check fails.    """    try:        document = json.loads(frame.decode("utf-8"))        scheme = document["scheme"]        payload_b64 = document["payload"]        signature_b64 = document["signature"]    except (UnicodeDecodeError, KeyError, json.JSONDecodeError) as exc:        raise FrameFormatError("Could not decode signature frame") from exc    payload = base64.b64decode(payload_b64)    signature = base64.b64decode(signature_b64)    if not verify_message(payload, signature, scheme=scheme, public_key=public_key):        raise InvalidSignatureError("Signature check failed")    return payload, scheme